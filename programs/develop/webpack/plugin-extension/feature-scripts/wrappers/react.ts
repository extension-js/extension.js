import * as path from 'path'
import * as fs from 'fs'

// Extract CSS imports from the source file
function extractCSSImports(source: string): string[] {
  const cssImports: string[] = []

  // Split source into lines and process each line
  const lines = source.split('\n')

  // Match various CSS import patterns (excluding commented lines)
  const cssImportPatterns = [
    /^\s*import\s+['"]([^'"]*\.(?:css|scss|sass|less|module\.css))['"]/,
    /^\s*import\s+['"]([^'"]*\.(?:css|scss|sass|less|module\.css))['"]\s*;?\s*$/,
    /^\s*import\s+['"]([^'"]*\.(?:css|scss|sass|less|module\.css))['"]\s*from\s+['"][^'"]*['"]/
  ]

  for (const line of lines) {
    // Skip commented lines
    const trimmedLine = line.trim()
    if (trimmedLine.startsWith('//') || trimmedLine.startsWith('/*')) {
      continue
    }

    for (const pattern of cssImportPatterns) {
      const match = pattern.exec(line)
      if (match) {
        const cssPath = match[1]
        if (cssPath && !cssImports.includes(cssPath)) {
          cssImports.push(cssPath)
        }
      }
    }
  }

  return cssImports
}

// Extract CSS URLs referenced via new URL('./styles.css', import.meta.url)
function extractCssUrlsViaNewURL(source: string): string[] {
  const matches: string[] = []
  const re =
    /new\s+URL\(\s*['"]([^'"\n]+\.(?:css|scss|sass|less))['"]\s*,\s*import\.meta\.url\s*\)/g
  let m
  while ((m = re.exec(source))) {
    if (m[1] && !matches.includes(m[1])) matches.push(m[1])
  }
  return matches
}

export function generateReactWrapperCode(
  source: string,
  resourcePath: string
): string {
  const fileName = path.basename(resourcePath, path.extname(resourcePath))
  const cssImports = Array.from(
    new Set([...extractCSSImports(source), ...extractCssUrlsViaNewURL(source)])
  )
  const resourceDir = path.dirname(resourcePath)

  if (process.env.EXTENSION_ENV === 'development') {
    console.log(
      `[Extension.js] Detected React framework with CSS imports:`,
      cssImports
    )
  }

  // Read CSS content at build time for hardcoding
  const cssContentMap: Record<string, string> = {}
  for (const cssImport of cssImports) {
    try {
      const cssPath = path.resolve(resourceDir, cssImport)
      if (fs.existsSync(cssPath)) {
        const cssContent = fs.readFileSync(cssPath, 'utf-8')
        // Escape the CSS content for JavaScript string
        const escapedCSS = cssContent
          .replace(/\\/g, '\\\\')
          .replace(/`/g, '\\`')
          .replace(/\${/g, '\\${')
          .replace(/\n/g, ' ')
          .replace(/\s+/g, ' ')
          .trim()
        cssContentMap[cssImport] = escapedCSS
        if (process.env.EXTENSION_ENV === 'development') {
          console.log(
            `[Extension.js] Read CSS content for ${cssImport}, length: ${cssContent.length}`
          )
        }
      } else {
        if (process.env.EXTENSION_ENV === 'development') {
          console.warn(`[Extension.js] CSS file not found: ${cssPath}`)
        }
      }
    } catch (error) {
      if (process.env.EXTENSION_ENV === 'development') {
        console.warn(
          `[Extension.js] Failed to read CSS file ${cssImport}:`,
          error
        )
      }
    }
  }

  // Generate TypeScript-compatible code for React (dynamic user import + HMR guards)
  const wrapperCode = `
// React Content Script Wrapper - Auto-generated by Extension.js
// This wrapper provides Shadow DOM isolation and CSS injection for React content scripts

// User content script will be dynamically imported to isolate syntax/runtime errors

// Content script options interface
export interface ContentScriptOptions {
  rootElement?: string
  rootClassName?: string
  stylesheets?: string[]
}

// Content script instance interface
export interface ContentScriptInstance {
  mount: (container: HTMLElement) => void
  unmount: () => void
}

// React Content script wrapper class
class ReactContentScriptWrapper {
  private rootElement: HTMLElement | null = null
  private shadowRoot: ShadowRoot | null = null
  private styleElement: HTMLStyleElement | null = null
  private renderFunction: (container: HTMLElement) => (() => void) | void
  private unmountFunction: (() => void) | null = null
  private options: ContentScriptOptions

  constructor(renderFunction: (container: HTMLElement) => (() => void) | void, options: ContentScriptOptions = {}) {
    this.renderFunction = renderFunction
    this.options = {
      rootElement: 'extension-root',
      rootClassName: undefined, // React handles its own styling
      stylesheets: ${JSON.stringify(cssImports)},
      ...options
    }
  }

  async mount(container?: HTMLElement): Promise<void> {
    if (this.rootElement) {
      this.unmount()
    }

    // Create root element - React handles its own container styling
    this.rootElement = container || document.createElement('div')
    this.rootElement.id = this.options.rootElement!
    try { this.rootElement.setAttribute('data-extension-root', 'true') } catch {}
    if (this.options.rootClassName) {
      this.rootElement.className = this.options.rootClassName
    }
    // React component handles its own styling

    // Create shadow root for style isolation
    this.shadowRoot = this.rootElement.attachShadow({ mode: 'open' })

    // Create a host element inside the shadow root for rendering
    const host = document.createElement('div')
    this.shadowRoot.appendChild(host)

    // Inject styles FIRST
    await this.injectStyles()

    // Render React content
    try {
      const result = this.renderFunction(host)
      if (typeof result === 'function') {
        this.unmountFunction = result
      }
    } catch (error) {
      console.error('[Extension.js] React render failed:', error)
      return
    }

    // Append to document if no container provided
    if (!container) {
      document.body.appendChild(this.rootElement)
    }
  }

  unmount() {
    if (this.unmountFunction) {
      this.unmountFunction()
      this.unmountFunction = null
    }

    if (this.rootElement && this.rootElement.parentNode) {
      this.rootElement.parentNode.removeChild(this.rootElement)
    }

    this.rootElement = null
    this.shadowRoot = null
    this.styleElement = null
  }

  // Inject styles with hardcoded CSS content for React templates
  private async injectStyles(): Promise<void> {
    const targetRoot = this.shadowRoot || this.rootElement!

    // Create style element
    this.styleElement = document.createElement('style')
    targetRoot.appendChild(this.styleElement)

    // Fetch CSS content
    try {
      const cssContent = await this.fetchCSS()
      this.styleElement.textContent = cssContent
    } catch (error) {
      console.error('[Extension.js] Failed to inject React CSS:', error)
    }

    // Setup HMR for CSS files
    this.setupCSSHMR()
  }

  // Fetch CSS with hardcoded content for React templates
  private async fetchCSS(): Promise<string> {
    let allCSS = ''

    // CSS content map is injected at build time
    const cssContentMap: Record<string, string> = ${JSON.stringify(cssContentMap)}

    for (const stylesheet of this.options.stylesheets) {
      try {
        // Check if we have hardcoded content for this stylesheet
        if (cssContentMap[stylesheet]) {
          const cssContent = cssContentMap[stylesheet]
          allCSS += cssContent + '\\n'
          continue
        }

        // For stylesheets without hardcoded content, try to fetch them
        const cssUrl = new URL(stylesheet, import.meta.url)
        const response = await fetch(cssUrl)
        const text = await response.text()
        if (response.ok) {
          allCSS += text + '\\n'
        } else {
          console.warn('[Extension.js] Failed to fetch CSS:', stylesheet)
        }
      } catch (error) {
        console.warn('[Extension.js] Failed to fetch React CSS:', stylesheet, error)
      }
    }

    const result = allCSS || '/* No CSS loaded */'
    return result
  }

  // Setup CSS HMR for React templates
  private setupCSSHMR() {
    if (!import.meta.webpackHot) return

    // Setup HMR for each CSS file
    for (const stylesheet of this.options.stylesheets) {
      import.meta.webpackHot?.accept(stylesheet, async () => {
        try {
          const cssContent = await this.fetchCSS()
          if (this.styleElement) {
            this.styleElement.textContent = cssContent
          }
        } catch (error) {
          console.error('[Extension.js] Failed to update React CSS via HMR:', stylesheet, error)
        }
      })
    }
  }
}

// Simple initialization for React
let __extensionjs_unmount: (() => void) | undefined

const __EXTENSIONJS_GUARD_KEY__ = '__extensionjs_init_guard__'
function __extensionjs_shouldThrottleInit__(): boolean {
  try {
    const w: any = (globalThis as any) || (window as any)
    const now = Date.now()
    const state = w[__EXTENSIONJS_GUARD_KEY__] || {attempts: 0, last: 0, blockedUntil: 0}
    if (state.blockedUntil && now < state.blockedUntil) return true
    if (now - state.last < 1500) state.attempts += 1
    else state.attempts = 1
    state.last = now
    if (state.attempts >= 3) state.blockedUntil = now + 5000
    w[__EXTENSIONJS_GUARD_KEY__] = state
    return state.blockedUntil && now < state.blockedUntil
  } catch {
    return false
  }
}

// HMR-safe versioning to ignore late async work from disposed modules
let __extensionjs_current_version = 0
let __extensionjs_isDisposed = false
let __extensionjs_needsReinit = false
let __extensionjs_blockedUntil = 0
try {
  const hot: any = (import.meta as any).webpackHot
  if (hot) {
    const data = (hot.data = hot.data || {})
    data.__extensionjs_version = (data.__extensionjs_version || 0) + 1
    __extensionjs_current_version = data.__extensionjs_version
    if (typeof data.__extensionjs_needsReinit === 'boolean') {
      __extensionjs_needsReinit = data.__extensionjs_needsReinit
    }
    if (typeof data.__extensionjs_blockedUntil === 'number') {
      __extensionjs_blockedUntil = data.__extensionjs_blockedUntil
    }
  }
} catch {}

async function initialize() {
  if (__extensionjs_shouldThrottleInit__()) {
    console.warn('[Extension.js] Throttling React initialize to avoid reload loop')
    return
  }
  if (__extensionjs_isDisposed) return
  if (__extensionjs_blockedUntil && Date.now() < __extensionjs_blockedUntil) return
  if (__extensionjs_unmount) {
    __extensionjs_unmount()
  }
  try {
    const initVersion = __extensionjs_current_version
    // Dynamically import user module so syntax errors do not break this core file
    const userModule: any = await import(/* webpackMode: "eager" */ '__EXTENSIONJS_USER_REQUEST__')
    if (__extensionjs_isDisposed || initVersion !== __extensionjs_current_version) {
      return
    }
    const renderFunction = (userModule && userModule.default) || (userModule && userModule.contentScript)
    if (typeof renderFunction !== 'function') {
      throw new Error('[Extension.js] React wrapper: user module default export is not a function')
    }
    const wrapper = new ReactContentScriptWrapper(renderFunction, {})
    await wrapper.mount()
    if (__extensionjs_isDisposed || initVersion !== __extensionjs_current_version) {
      try { wrapper.unmount() } catch {}
      return
    }
    __extensionjs_unmount = () => wrapper.unmount()
    __extensionjs_needsReinit = false
    __extensionjs_blockedUntil = 0
  } catch (e) {
    console.error('[Extension.js] React wrapper initialize failed:', e)
    try {
      const w: any = (globalThis as any) || (window as any)
      const state = w[__EXTENSIONJS_GUARD_KEY__] || {attempts: 0, last: 0, blockedUntil: 0}
      const now = Date.now()
      const isSyntax = e && (e.name === 'SyntaxError' || /Unexpected token|Unexpected end of/.test(String(e.message || '')))
      state.blockedUntil = now + (isSyntax ? 10000 : 5000)
      state.attempts = (state.attempts || 0) + 1
      state.last = now
      w[__EXTENSIONJS_GUARD_KEY__] = state
      __extensionjs_needsReinit = true
      __extensionjs_blockedUntil = state.blockedUntil
      // Dev-only hard reload request on syntax error, with cooldown
      if (isSyntax && (import.meta as any).env?.MODE !== 'production') {
        try {
          const key = '__extensionjs_last_hard_reload__'
          const last = Number(sessionStorage.getItem(key) || 0)
          if (!last || now - last > 8000) {
            sessionStorage.setItem(key, String(now))
            let sent = false
            try {
              chrome?.runtime?.sendMessage?.(
                {type: 'EXT_JS_HARD_RELOAD', reason: 'syntax-error'},
                () => { sent = true }
              )
            } catch {}
            setTimeout(() => {
              try { if (!sent && chrome?.runtime?.reload) { chrome.runtime.reload(); sent = true } } catch {}
              try { if (!sent) { location.reload() } } catch {}
            }, 800)
          }
        } catch {}
      }
    } catch {}
  }
}

if (import.meta.webpackHot) {
  import.meta.webpackHot?.accept()
  import.meta.webpackHot?.dispose(() => {
    __extensionjs_isDisposed = true
    try { __extensionjs_unmount?.() } catch {}
  })
  // Accept updates to the user module without immediate re-init; drive from status handler
  try { import.meta.webpackHot?.accept('__EXTENSIONJS_USER_REQUEST__') } catch {}
  try {
    import.meta.webpackHot?.setStatusHandler((status: string) => {
      if (status === 'fail' || status === 'abort') {
        try {
          const w: any = (globalThis as any) || (window as any)
          const now = Date.now()
          const state = w[__EXTENSIONJS_GUARD_KEY__] || {attempts: 0, last: 0, blockedUntil: 0}
          state.blockedUntil = now + 5000
          state.attempts = (state.attempts || 0) + 1
          state.last = now
          w[__EXTENSIONJS_GUARD_KEY__] = state
          __extensionjs_needsReinit = true
          __extensionjs_blockedUntil = state.blockedUntil
        } catch {}
      }
      if (status === 'apply' || status === 'ready') {
        __extensionjs_needsReinit = true
      }
      if (status === 'idle') {
        try {
          const hot: any = (import.meta as any).webpackHot
          if (hot) {
            const data = (hot.data = hot.data || {})
            data.__extensionjs_needsReinit = __extensionjs_needsReinit
            data.__extensionjs_blockedUntil = __extensionjs_blockedUntil
          }
        } catch {}
        if (__extensionjs_needsReinit && !__extensionjs_shouldThrottleInit__() && (!__extensionjs_blockedUntil || Date.now() >= __extensionjs_blockedUntil)) {
          __extensionjs_needsReinit = false
          try { location.reload() } catch {}
        }
      }
    })
  } catch {}
}

if (document.readyState === 'complete') {
  initialize()
} else {
  document.addEventListener('readystatechange', () => {
    if (document.readyState === 'complete') {
      initialize()
    }
  })
}

export default ReactContentScriptWrapper
`

  return wrapperCode
}
