import * as path from 'path'
import * as fs from 'fs'

// Extract CSS imports from the source file
function extractCSSImports(source: string): string[] {
  const cssImports: string[] = []

  // Split source into lines and process each line
  const lines = source.split('\n')

  // Match various CSS import patterns (excluding commented lines)
  const cssImportPatterns = [
    /^\s*import\s+['"]([^'\"]*\.(?:css|scss|sass|less|module\.css))['"]/,
    /^\s*import\s+['"]([^'\"]*\.(?:css|scss|sass|less|module\.css))['"]\s*;?\s*$/,
    /^\s*import\s+['"]([^'\"]*\.(?:css|scss|sass|less|module\.css))['"]\s*from\s+['"][^'\"]*['"]/
  ]

  for (const line of lines) {
    // Skip commented lines
    const trimmedLine = line.trim()
    if (trimmedLine.startsWith('//') || trimmedLine.startsWith('/*')) {
      continue
    }

    for (const pattern of cssImportPatterns) {
      const match = pattern.exec(line)
      if (match) {
        const cssPath = match[1]
        if (cssPath && !cssImports.includes(cssPath)) {
          cssImports.push(cssPath)
        }
      }
    }
  }

  return cssImports
}

// Extract CSS URLs referenced via new URL('./styles.css', import.meta.url)
function extractCssUrlsViaNewURL(source: string): string[] {
  const matches: string[] = []
  const re =
    /new\s+URL\(\s*['"]([^'"\n]+\.(?:css|scss|sass|less))['"]\s*,\s*import\.meta\.url\s*\)/g
  let m
  while ((m = re.exec(source))) {
    if (m[1] && !matches.includes(m[1])) matches.push(m[1])
  }
  return matches
}

export function generatePreactWrapperCode(
  source: string,
  resourcePath: string
): string {
  const cssImports = Array.from(
    new Set([...extractCSSImports(source), ...extractCssUrlsViaNewURL(source)])
  )
  const resourceDir = path.dirname(resourcePath)

  if (process.env.EXTENSION_ENV === 'development') {
    console.log(
      `[Extension.js] Detected Preact framework with CSS imports:`,
      cssImports
    )
  }

  // Read CSS content at build time for hardcoding
  const cssContentMap: Record<string, string> = {}
  for (const cssImport of cssImports) {
    try {
      const cssPath = path.resolve(resourceDir, cssImport)
      if (fs.existsSync(cssPath)) {
        const cssContent = fs.readFileSync(cssPath, 'utf-8')
        // Escape for JS template literal
        const escapedCSS = cssContent
          .replace(/\\/g, '\\\\')
          .replace(/`/g, '\\`')
          .replace(/\${/g, '\\${')
          .replace(/\n/g, ' ')
          .replace(/\s+/g, ' ')
          .trim()
        cssContentMap[cssImport] = escapedCSS
      }
    } catch {}
  }

  // Normalize default export to an internal alias so wrappers are name-agnostic
  function normalizeDefaultExport(input: string) {
    const hasDefault = /\bexport\s+default\s+/.test(input)
    if (!hasDefault) return {code: input, hasDefault}
    const replaced = input.replace(
      /\bexport\s+default\s+/,
      'const __extensionjs_default = '
    )
    return {
      code: replaced + '\n;export default __extensionjs_default',
      hasDefault
    }
  }
  const {code: normalizedSource} = normalizeDefaultExport(source)

  const wrapperCode = `
// Preact Content Script Wrapper - Auto-generated by Extension.js
// This wrapper provides Shadow DOM isolation and CSS injection for Preact content scripts

// User content script will be dynamically imported to isolate syntax/runtime errors

export interface ContentScriptOptions {
  rootElement?: string
  rootClassName?: string
  stylesheets?: string[]
}

export interface ContentScriptInstance {
  mount: (container: HTMLElement) => void
  unmount: () => void
}

class PreactContentScriptWrapper {
  private rootElement: HTMLElement | null = null
  private shadowRoot: ShadowRoot | null = null
  private styleElement: HTMLStyleElement | null = null
  private renderFunction: (container: HTMLElement) => (() => void) | void
  private unmountFunction: (() => void) | null = null
  private options: ContentScriptOptions

  constructor(renderFunction: (container: HTMLElement) => (() => void) | void, options: ContentScriptOptions = {}) {
    this.renderFunction = renderFunction
    this.options = {
      rootElement: 'extension-root',
      rootClassName: undefined,
      stylesheets: ${JSON.stringify(cssImports)},
      ...options
    }
  }

  async mount(container?: HTMLElement): Promise<void> {
    if (this.rootElement) {
      this.unmount()
    }

    this.rootElement = container || document.createElement('div')
    this.rootElement.id = this.options.rootElement!
    try { this.rootElement.setAttribute('data-extension-root', 'true') } catch {}
    if (this.options.rootClassName) {
      this.rootElement.className = this.options.rootClassName
    }

    this.shadowRoot = this.rootElement.attachShadow({ mode: 'open' })

    const host = document.createElement('div')
    this.shadowRoot.appendChild(host)

    await this.injectStyles()

    try {
      const result = this.renderFunction(host)
      if (typeof result === 'function') {
        this.unmountFunction = result
      }
    } catch (error) {
      console.error('[Extension.js] Preact render failed:', error)
      return
    }

    if (!container) {
      document.body.appendChild(this.rootElement)
    }
  }

  unmount() {
    if (this.unmountFunction) {
      try { this.unmountFunction() } catch {}
      this.unmountFunction = null
    }
    if (this.rootElement && this.rootElement.parentNode) {
      this.rootElement.parentNode.removeChild(this.rootElement)
    }
    this.rootElement = null
    this.shadowRoot = null
    this.styleElement = null
  }

  private async injectStyles(): Promise<void> {
    const targetRoot = this.shadowRoot || this.rootElement!
    this.styleElement = document.createElement('style')
    targetRoot.appendChild(this.styleElement)

    try {
      const cssContent = await this.fetchCSS()
      this.styleElement.textContent = cssContent
    } catch (error) {
      console.error('[Extension.js] Failed to inject Preact CSS:', error)
    }
    this.setupCSSHMR()
  }

  private async fetchCSS(): Promise<string> {
    let allCSS = ''
    const cssContentMap: Record<string, string> = ${JSON.stringify(cssContentMap)}
    for (const stylesheet of this.options.stylesheets || []) {
      try {
        if (cssContentMap[stylesheet]) {
          allCSS += cssContentMap[stylesheet] + '\n'
          continue
        }
        const cssUrl = new URL(stylesheet, import.meta.url)
        const response = await fetch(cssUrl)
        const text = await response.text()
        if (response.ok) allCSS += text + '\n'
      } catch (error) {
        console.warn('[Extension.js] Failed to fetch Preact CSS:', stylesheet, error)
      }
    }
    return allCSS || '/* No CSS loaded */'
  }

  private setupCSSHMR() {
    if (!import.meta.webpackHot) return
    for (const stylesheet of this.options.stylesheets || []) {
      import.meta.webpackHot?.accept(stylesheet, async () => {
        try {
          const cssContent = await this.fetchCSS()
          if (this.styleElement) this.styleElement.textContent = cssContent
        } catch (error) {
          console.error('[Extension.js] Failed to update Preact CSS via HMR:', stylesheet, error)
        }
      })
    }
  }
}

function initializePreactContentScript(
  options: ContentScriptOptions,
  renderFunction: (container: HTMLElement) => (() => void) | void
): ContentScriptInstance {
  const wrapper = new PreactContentScriptWrapper(renderFunction, options)
  return {
    mount: (container?: HTMLElement) => wrapper.mount(container),
    unmount: () => wrapper.unmount()
  }
}

export function autoInitializePreactContentScript(
  options: ContentScriptOptions = {}
): ContentScriptInstance {
  // Placeholder; actual render function resolved at runtime via dynamic import
  const renderFunction = (container: HTMLElement) => {}
  return initializePreactContentScript(options, renderFunction)
}

let __extensionjs_unmount: (() => void) | undefined

const __EXTENSIONJS_GUARD_KEY__ = '__extensionjs_preact_init_guard__'
function __extensionjs_shouldThrottleInit__(): boolean {
  try {
    const w: any = (globalThis as any) || (window as any)
    const now = Date.now()
    const state = w[__EXTENSIONJS_GUARD_KEY__] || {attempts: 0, last: 0, blockedUntil: 0}
    if (state.blockedUntil && now < state.blockedUntil) return true
    if (now - state.last < 1500) state.attempts += 1
    else state.attempts = 1
    state.last = now
    if (state.attempts >= 3) state.blockedUntil = now + 5000
    w[__EXTENSIONJS_GUARD_KEY__] = state
    return state.blockedUntil && now < state.blockedUntil
  } catch {
    return false
  }
}

// HMR-safe versioning to ignore late async work from disposed modules
let __extensionjs_current_version = 0
let __extensionjs_isDisposed = false
let __extensionjs_needsReinit = false
let __extensionjs_blockedUntil = 0
try {
  const hot: any = (import.meta as any).webpackHot
  if (hot) {
    const data = (hot.data = hot.data || {})
    data.__extensionjs_version = (data.__extensionjs_version || 0) + 1
    __extensionjs_current_version = data.__extensionjs_version
    // restore persisted flags
    if (typeof data.__extensionjs_needsReinit === 'boolean') {
      __extensionjs_needsReinit = data.__extensionjs_needsReinit
    }
    if (typeof data.__extensionjs_blockedUntil === 'number') {
      __extensionjs_blockedUntil = data.__extensionjs_blockedUntil
    }
  }
} catch {}

async function initialize() {
  if (__extensionjs_shouldThrottleInit__()) {
    console.warn('[Extension.js] Throttling Preact initialize to avoid reload loop')
    return
  }
  if (__extensionjs_isDisposed) {
    // Ignore initialize calls after dispose until next evaluate
    return
  }
  if (__extensionjs_blockedUntil && Date.now() < __extensionjs_blockedUntil) {
    return
  }
  if (__extensionjs_unmount) {
    __extensionjs_unmount()
  }
  try {
    // Capture version at start; ignore results if module was replaced
    const initVersion = __extensionjs_current_version
    // Dynamically import user module so syntax errors do not break this core file
    const userModule: any = await import(/* webpackMode: "eager" */ '__EXTENSIONJS_USER_REQUEST__')
    if (__extensionjs_isDisposed || initVersion !== __extensionjs_current_version) {
      return
    }
    const renderFunction = (userModule && userModule.default) || (userModule && userModule.contentScript)
    if (typeof renderFunction !== 'function') {
      throw new Error('[Extension.js] Preact wrapper: user module default export is not a function')
    }
    const wrapper = new PreactContentScriptWrapper(renderFunction, {})
    await wrapper.mount()
    if (__extensionjs_isDisposed || initVersion !== __extensionjs_current_version) {
      try { wrapper.unmount() } catch {}
      return
    }
    __extensionjs_unmount = () => wrapper.unmount()
    __extensionjs_needsReinit = false
    __extensionjs_blockedUntil = 0
  } catch (e) {
    console.error('[Extension.js] Preact wrapper initialize failed:', e)
    try {
      const w: any = (globalThis as any) || (window as any)
      const state = w[__EXTENSIONJS_GUARD_KEY__] || {attempts: 0, last: 0, blockedUntil: 0}
      const now = Date.now()
      const isSyntax = e && (e.name === 'SyntaxError' || /Unexpected token|Unexpected end of/.test(String(e.message || '')))
      state.blockedUntil = now + (isSyntax ? 10000 : 5000)
      state.attempts = (state.attempts || 0) + 1
      state.last = now
      w[__EXTENSIONJS_GUARD_KEY__] = state
      __extensionjs_needsReinit = true
      __extensionjs_blockedUntil = state.blockedUntil
      // Dev-only hard reload request on syntax error, with cooldown
      if (isSyntax && (import.meta as any).env?.MODE !== 'production') {
        try {
          const key = '__extensionjs_last_hard_reload__'
          const last = Number(sessionStorage.getItem(key) || 0)
          if (!last || now - last > 8000) {
            sessionStorage.setItem(key, String(now))
            let sent = false
            try {
              chrome?.runtime?.sendMessage?.(
                {type: 'EXT_JS_HARD_RELOAD', reason: 'syntax-error'},
                () => {
                  sent = true
                }
              )
            } catch {}
            // Fallback: if message doesn’t trigger (no SW), attempt direct extension reload
            setTimeout(() => {
              try {
                if (!sent && chrome?.runtime?.reload) {
                  chrome.runtime.reload()
                  sent = true
                }
              } catch {}
              // Last resort: reload page to break loop; wrapper will re-mount after fix
              try {
                if (!sent) {
                  location.reload()
                }
              } catch {}
            }, 800)
          }
        } catch {}
      }
    } catch {}
  }
}

if (import.meta.webpackHot) {
  import.meta.webpackHot?.accept()
  import.meta.webpackHot?.dispose(() => {
    __extensionjs_isDisposed = true
    try { __extensionjs_unmount?.() } catch {}
  })
  // Accept module and user updates without immediate re-init; drive re-init from status handler when idle
  try { import.meta.webpackHot?.accept('__EXTENSIONJS_USER_REQUEST__') } catch {}
  // Back off if HMR enters fail/abort to avoid hot-reload storms
  try {
    import.meta.webpackHot?.setStatusHandler((status: string) => {
      if (status === 'fail' || status === 'abort') {
        try {
          const w: any = (globalThis as any) || (window as any)
          const now = Date.now()
          const state = w[__EXTENSIONJS_GUARD_KEY__] || {attempts: 0, last: 0, blockedUntil: 0}
          state.blockedUntil = now + 5000
          state.attempts = (state.attempts || 0) + 1
          state.last = now
          w[__EXTENSIONJS_GUARD_KEY__] = state
          __extensionjs_needsReinit = true
          __extensionjs_blockedUntil = state.blockedUntil
        } catch {}
      }
      if (status === 'apply' || status === 'ready') {
        __extensionjs_needsReinit = true
      }
      if (status === 'idle') {
        try {
          const hot: any = (import.meta as any).webpackHot
          if (hot) {
            const data = (hot.data = hot.data || {})
            data.__extensionjs_needsReinit = __extensionjs_needsReinit
            data.__extensionjs_blockedUntil = __extensionjs_blockedUntil
          }
        } catch {}
        if (__extensionjs_needsReinit && !__extensionjs_shouldThrottleInit__() && (!__extensionjs_blockedUntil || Date.now() >= __extensionjs_blockedUntil)) {
          __extensionjs_needsReinit = false
          // Perform a single hard page reload to avoid HMR storms
          try { location.reload() } catch { /* ignore */ }
        }
      }
    })
  } catch {}
}

if (document.readyState === 'complete') {
  initialize()
} else {
  document.addEventListener('readystatechange', () => {
    if (document.readyState === 'complete') {
      initialize()
    }
  })
}

export default PreactContentScriptWrapper
`

  return wrapperCode
}
