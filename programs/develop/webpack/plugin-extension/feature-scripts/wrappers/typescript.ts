import * as path from 'path'
import * as fs from 'fs'

// Extract CSS imports from the source file
function extractCSSImports(source: string): string[] {
  const cssImports: string[] = []

  // Split source into lines and process each line
  const lines = source.split('\n')

  // Match various CSS import patterns (excluding commented lines)
  const cssImportPatterns = [
    /^\s*import\s+['"]([^'"]*\.(?:css|scss|sass|less|module\.css))['"]/,
    /^\s*import\s+['"]([^'"]*\.(?:css|scss|sass|less|module\.css))['"]\s*;?\s*$/,
    /^\s*import\s+['"]([^'"]*\.(?:css|scss|sass|less|module\.css))['"]\s*from\s+['"][^'"]*['"]/
  ]

  for (const line of lines) {
    // Skip commented lines
    const trimmedLine = line.trim()
    if (trimmedLine.startsWith('//') || trimmedLine.startsWith('/*')) {
      continue
    }

    for (const pattern of cssImportPatterns) {
      const match = pattern.exec(line)
      if (match) {
        const cssPath = match[1]
        if (cssPath && !cssImports.includes(cssPath)) {
          cssImports.push(cssPath)
        }
      }
    }
  }

  return cssImports
}

export function generateTypeScriptWrapperCode(
  source: string,
  resourcePath: string
): string {
  const fileName = path.basename(resourcePath, path.extname(resourcePath))
  const cssImports = Array.from(
    new Set([
      ...extractCSSImports(source),
      ...(() => {
        // Also detect new URL('./styles.css', import.meta.url)
        const matches: string[] = []
        const re =
          /new\s+URL\(\s*['"]([^'"\n]+\.(?:css|scss|sass|less))['"]\s*,\s*import\.meta\.url\s*\)/g
        let m
        while ((m = re.exec(source))) {
          if (m[1] && !matches.includes(m[1])) matches.push(m[1])
        }
        return matches
      })()
    ])
  )
  const resourceDir = path.dirname(resourcePath)

  if (process.env.EXTENSION_ENV === 'development') {
    console.log(
      `[Extension.js] Detected TypeScript framework with CSS imports:`,
      cssImports
    )
  }

  // Read CSS content at build time for hardcoding
  const cssContentMap: Record<string, string> = {}
  for (const cssImport of cssImports) {
    try {
      const cssPath = path.resolve(resourceDir, cssImport)
      if (fs.existsSync(cssPath)) {
        const cssContent = fs.readFileSync(cssPath, 'utf-8')
        // Escape the CSS content for JavaScript string
        const escapedCSS = cssContent
          .replace(/\\/g, '\\\\')
          .replace(/`/g, '\\`')
          .replace(/\${/g, '\\${')
          .replace(/\n/g, ' ')
          .replace(/\s+/g, ' ')
          .trim()
        cssContentMap[cssImport] = escapedCSS
        if (process.env.EXTENSION_ENV === 'development') {
          console.log(
            `[Extension.js] Read CSS content for ${cssImport}, length: ${cssContent.length}`
          )
        }
      } else {
        if (process.env.EXTENSION_ENV === 'development') {
          console.warn(`[Extension.js] CSS file not found: ${cssPath}`)
        }
      }
    } catch (error) {
      if (process.env.EXTENSION_ENV === 'development') {
        console.warn(
          `[Extension.js] Failed to read CSS file ${cssImport}:`,
          error
        )
      }
    }
  }

  // Normalize default export to an internal alias so wrappers are name-agnostic
  function normalizeDefaultExport(input: string) {
    const hasDefault = /\bexport\s+default\s+/.test(input)
    if (!hasDefault) return {code: input, hasDefault}
    const replaced = input.replace(
      /\bexport\s+default\s+/,
      'const __extensionjs_default = '
    )
    return {
      code: replaced + '\n;export default __extensionjs_default',
      hasDefault
    }
  }
  const {code: normalizedSource} = normalizeDefaultExport(source)

  // Safely embed original source by escaping template literal breakers
  const processedSource = normalizedSource
    .replace(/'use shadow-dom'/g, "// 'use shadow-dom'")
    .replace(/"use shadow-dom"/g, '// "use shadow-dom"')
  const escapedProcessedSource = processedSource
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\$\{/g, '\\\${')

  // Generate TypeScript-compatible code
  const wrapperCode = `
// TypeScript Content Script Wrapper - Auto-generated by Extension.js
// This wrapper provides Shadow DOM isolation and CSS injection for TypeScript content scripts
const __EXT_TS_DEV__ = !!(import.meta.webpackHot)

// Original TypeScript content script source (directive processed)
${escapedProcessedSource}

// Content script options interface
export interface ContentScriptOptions {
  rootElement?: string
  rootClassName?: string
  stylesheets?: string[]
}

// Content script instance interface
export interface ContentScriptInstance {
  mount: (container: HTMLElement) => void
  unmount: () => void
}

// TypeScript Content script wrapper class
class TypeScriptContentScriptWrapper {
  private rootElement: HTMLElement | null = null
  private shadowRoot: ShadowRoot | null = null
  private styleElement: HTMLStyleElement | null = null
  private renderFunction: (container: HTMLElement) => (() => void) | void
  private unmountFunction: (() => void) | null = null
  private options: ContentScriptOptions

  constructor(renderFunction: (container: HTMLElement) => (() => void) | void, options: ContentScriptOptions = {}) {
    this.renderFunction = renderFunction
    this.options = {
      rootElement: 'extension-root',
      rootClassName: undefined, // TypeScript handles its own styling
      stylesheets: ${JSON.stringify(cssImports)},
      ...options
    }
  }

  async mount(container?: HTMLElement): Promise<void> {
    if (this.rootElement) {
      this.unmount()
    }

    // Create root element - TypeScript handles its own container styling
    this.rootElement = container || document.createElement('div')
    this.rootElement.id = this.options.rootElement!
    try { this.rootElement.setAttribute('data-extension-root', 'true') } catch {}
    if (this.options.rootClassName) {
      this.rootElement.className = this.options.rootClassName
    }

    // Create shadow root for style isolation
    this.shadowRoot = this.rootElement.attachShadow({ mode: 'open' })

    // Inject styles FIRST
    await this.injectStyles()

    // Render TypeScript content
    // Ensure user code that appends to document.body is redirected into our host
    const host: any = document.createElement('div')
    this.shadowRoot.appendChild(host)
    const body = document.body as any
    const originalAppend = body && body.appendChild ? body.appendChild.bind(body) : null
    const originalInsertBefore = body && body.insertBefore ? body.insertBefore.bind(body) : null
    let originalAttachShadow: any
    try {
      if (body) {
        // Swallow body appends during user render to avoid empty light DOM hosts
        body.appendChild = (node: any) => node
        body.insertBefore = (node: any, ref: any) => node
      }
      // Prevent nested shadow roots created by user code; reuse wrapper shadow root
      if ((Element as any).prototype && (Element as any).prototype.attachShadow) {
        originalAttachShadow = (Element as any).prototype.attachShadow
        ;(Element as any).prototype.attachShadow = () => this.shadowRoot
      }
    } catch {}

    const result = this.renderFunction(host)
    if (typeof result === 'function') {
      this.unmountFunction = result
    }

    // Restore patched methods
    try {
      if (body && originalAppend) body.appendChild = originalAppend
      if (body && originalInsertBefore) body.insertBefore = originalInsertBefore
      if (originalAttachShadow) (Element as any).prototype.attachShadow = originalAttachShadow
    } catch {}

    // After user render, consolidate duplicate <style> tags under the shadow root
    try {
      this.dedupeStyles()
    } catch {}

    // If host remained empty (user appended directly to shadow root), remove it
    try {
      if (host && host.parentNode && host.childNodes && host.childNodes.length === 0) {
        host.parentNode.removeChild(host)
      }
    } catch {}

    // Append to document if no container provided
    if (!container) {
      document.body.appendChild(this.rootElement)
    }
  }

  unmount() {
    if (this.unmountFunction) {
      this.unmountFunction()
      this.unmountFunction = null
    }

    if (this.rootElement && this.rootElement.parentNode) {
      this.rootElement.parentNode.removeChild(this.rootElement)
    }

    this.rootElement = null
    this.shadowRoot = null
    this.styleElement = null
  }

  // Inject styles with hardcoded CSS content for TypeScript templates
  private async injectStyles(): Promise<void> {
    const targetRoot = this.shadowRoot || this.rootElement!

    // Create style element
    this.styleElement = document.createElement('style')
    targetRoot.appendChild(this.styleElement)

    // Fetch CSS content
    try {
      const cssContent = await this.fetchCSS()
      this.styleElement.textContent = cssContent
    } catch (error) {
      console.error('[Extension.js] Failed to inject TypeScript CSS:', error)
    }

    // Setup HMR for CSS files
    this.setupCSSHMR()
  }

  // Fetch CSS with hardcoded content for TypeScript templates
  private async fetchCSS(): Promise<string> {
    let allCSS = ''
    
    // CSS content map is injected at build time
    const cssContentMap: Record<string, string> = ${JSON.stringify(cssContentMap)}
    
    for (const stylesheet of this.options.stylesheets) {
      try {
        // Check if we have hardcoded content for this stylesheet
        if (cssContentMap[stylesheet]) {
          const cssContent = cssContentMap[stylesheet]
          allCSS += cssContent + '\\n'
          continue
        }
        
        // For stylesheets without hardcoded content, try to fetch them
        const cssUrl = new URL(stylesheet, import.meta.url)
        const response = await fetch(cssUrl)
        const text = await response.text()
        if (response.ok) {
          allCSS += text + '\\n'
        } else {
          console.warn('[Extension.js] Failed to fetch CSS:', stylesheet)
        }
      } catch (error) {
        console.warn('[Extension.js] Failed to fetch TypeScript CSS:', stylesheet, error)
      }
    }
    
    return allCSS
  }

  // Setup CSS HMR for TypeScript templates
  private setupCSSHMR() {
    if (!import.meta.webpackHot) return

    // Setup HMR for each CSS file
    for (const stylesheet of this.options.stylesheets) {
      import.meta.webpackHot?.accept(stylesheet, async () => {
        try {
          const cssContent = await this.fetchCSS()
          if (this.styleElement) {
            this.styleElement.textContent = cssContent
          }
        } catch (error) {
          console.error('[Extension.js] Failed to update TypeScript CSS via HMR:', stylesheet, error)
        }
      })
    }
  }

  // Remove duplicate style tags in the shadow root, keep the last one
  private dedupeStyles() {
    const root = this.shadowRoot || this.rootElement
    if (!root) return
    const styles = Array.from((root as any).querySelectorAll('style')) as HTMLStyleElement[]
    if (styles.length <= 1) return
    // Keep the last style (most recent content) and remove others
    for (let i = 0; i < styles.length - 1; i++) {
      try { styles[i].parentNode && styles[i].parentNode.removeChild(styles[i]) } catch {}
    }
  }
}

// Initialize TypeScript content script with wrapper
function initializeTypeScriptContentScript(
  options: ContentScriptOptions,
  renderFunction: (container: HTMLElement) => (() => void) | void
): ContentScriptInstance {
  const wrapper = new TypeScriptContentScriptWrapper(renderFunction, options)
  
  return {
    mount: (container?: HTMLElement) => wrapper.mount(container),
    unmount: () => wrapper.unmount()
  }
}

// Auto-initialize the TypeScript content script with the wrapper
export function autoInitializeTypeScriptContentScript(
  options: ContentScriptOptions = {}
): ContentScriptInstance {
  const renderFunction =
    (typeof __extensionjs_default === 'function' && __extensionjs_default) ||
    (typeof contentScript === 'function' ? contentScript : undefined)

  return initializeTypeScriptContentScript(options, renderFunction as any)
}

// Simple initialization for TypeScript
let __extensionjs_unmount: (() => void) | undefined

async function initialize() {
  if (__extensionjs_unmount) {
    __extensionjs_unmount()
  }
  
  const renderFunction =
    (typeof __extensionjs_default === 'function' && __extensionjs_default) ||
    (typeof contentScript === 'function' ? contentScript : undefined)
  if (!renderFunction) return
  try {
    const wrapper = new TypeScriptContentScriptWrapper(renderFunction, {})
    await wrapper.mount()
    __extensionjs_unmount = () => wrapper.unmount()
  } catch (e) {
    console.error('[Extension.js] TypeScript wrapper initialize failed:', e)
    try {
      const g: any = (globalThis as any) || (window as any)
      const key = '__extensionjs_ts_init_guard__'
      const now = Date.now()
      const state = g[key] || {attempts: 0, last: 0, blockedUntil: 0}
      const isSyntax = e && (e.name === 'SyntaxError' || /Unexpected token|Unexpected end of/.test(String(e.message || '')))
      state.blockedUntil = now + (isSyntax ? 10000 : 5000)
      state.attempts = (state.attempts || 0) + 1
      state.last = now
      g[key] = state
    } catch {}
    return
  }
}

if (import.meta.webpackHot) {
  import.meta.webpackHot?.accept()
  import.meta.webpackHot?.dispose(() => __extensionjs_unmount?.())

  // Accept changes to this file
  import.meta.webpackHot?.accept(() => {
    initialize()
  })
}

if (document.readyState === 'complete') {
  initialize()
} else {
  document.addEventListener('readystatechange', () => {
    if (document.readyState === 'complete') {
      initialize()
    }
  })
}

export default TypeScriptContentScriptWrapper
`

  return wrapperCode
}
