import * as path from 'path'
import * as fs from 'fs'
import {urlToRequest} from 'loader-utils'
import {validate} from 'schema-utils'
import {type Schema} from 'schema-utils/declarations/validate'
import {type LoaderContext} from '../../../webpack-types'
import {generateReactWrapperCode} from './react-content-script-wrapper'
import {generateVueWrapperCode} from './vue-content-script-wrapper'
import {generateSvelteWrapperCode} from './svelte-content-script-wrapper'
import {generatePreactWrapperCode} from './preact-content-script-wrapper'
import {generateTypeScriptWrapperCode} from './typescript-content-script-wrapper'

const schema: Schema = {
  type: 'object',
  properties: {
    test: {
      type: 'string'
    },
    manifestPath: {
      type: 'string'
    },
    mode: {
      type: 'string'
    },
    includeList: {
      type: 'object'
    },
    excludeList: {
      type: 'object'
    }
  }
}

/**
 * Check if the project is using a JavaScript framework
 */
function isUsingJSFramework(projectPath: string): boolean {
  const packageJsonPath = path.join(projectPath, 'package.json')

  if (!fs.existsSync(packageJsonPath)) {
    return false
  }

  const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'))

  const frameworks = [
    'react',
    'vue',
    '@angular/core',
    'svelte',
    'solid-js',
    'preact'
  ]

  const dependencies = packageJson.dependencies || {}
  const devDependencies = packageJson.devDependencies || {}

  for (const framework of frameworks) {
    if (dependencies[framework] || devDependencies[framework]) {
      return true
    }
  }

  return false
}

/**
 * Extract CSS imports from the source file
 */
function extractCSSImports(source: string): string[] {
  const cssImports: string[] = []

  // Split source into lines and process each line
  const lines = source.split('\n')

  // Match various CSS import patterns (excluding commented lines)
  const cssImportPatterns = [
    /^\s*import\s+['"]([^'"]*\.(?:css|scss|sass|less|module\.css))['"]/,
    /^\s*import\s+['"]([^'"]*\.(?:css|scss|sass|less|module\.css))['"]\s*;?\s*$/,
    /^\s*import\s+['"]([^'"]*\.(?:css|scss|sass|less|module\.css))['"]\s*from\s+['"][^'"]*['"]/
  ]

  for (const line of lines) {
    // Skip commented lines
    const trimmedLine = line.trim()
    if (trimmedLine.startsWith('//') || trimmedLine.startsWith('/*')) {
      continue
    }

    for (const pattern of cssImportPatterns) {
      const match = pattern.exec(line)
      if (match) {
        const cssPath = match[1]
        if (cssPath && !cssImports.includes(cssPath)) {
          cssImports.push(cssPath)
        }
      }
    }
  }

  return cssImports
}

/**
 * Detect framework type from source code and resource path
 */
function detectFramework(
  source: string,
  resourcePath: string
): 'react' | 'vue' | 'svelte' | 'preact' | 'typescript' | 'javascript' | null {
  if (
    source.includes('react') ||
    source.includes('ReactDOM') ||
    source.includes('createRoot') ||
    source.includes('render(')
  ) {
    return 'react'
  }

  if (
    source.includes('vue') ||
    source.includes('createApp') ||
    source.includes('mount(')
  ) {
    return 'vue'
  }

  if (source.includes('svelte') || source.includes('mount(')) {
    return 'svelte'
  }

  if (source.includes('preact') || source.includes('render(')) {
    return 'preact'
  }

  // Check file extension for TypeScript
  if (resourcePath.endsWith('.ts') && !resourcePath.endsWith('.d.ts')) {
    return 'typescript'
  }

  // Default to JavaScript if no specific framework detected
  return 'javascript'
}

/**
 * Generate framework-specific wrapper code
 */
function generateFrameworkWrapperCode(
  source: string,
  framework: string,
  resourcePath: string
): string {
  const fileName = path.basename(resourcePath, path.extname(resourcePath))
  const cssImports = extractCSSImports(source)

  console.log(
    `üîç Detected ${framework} framework with CSS imports:`,
    cssImports
  )

  // Generate React-specific wrapper code
  if (framework === 'react') {
    return generateReactWrapperCode(source, resourcePath)
  }

  if (framework === 'vue') {
    return generateVueWrapperCode(source, resourcePath)
  }

  if (framework === 'svelte') {
    return generateSvelteWrapperCode(source, resourcePath)
  }

  if (framework === 'preact') {
    return generatePreactWrapperCode(source, resourcePath)
  }

  if (framework === 'typescript') {
    return generateTypeScriptWrapperCode(source, resourcePath)
  }

  // Generate JavaScript-compatible code for JavaScript framework
  if (framework === 'javascript') {
    return `
// Content Script Wrapper - Auto-generated by Extension.js
// This wrapper provides Shadow DOM isolation and CSS injection for content scripts

// Original content script source
${source}

// Content script wrapper class
class ContentScriptWrapper {
  constructor(renderFunction, options = {}) {
    this.renderFunction = renderFunction
    this.options = {
      rootElement: 'extension-root',
      rootClassName: undefined,
      stylesheets: ${JSON.stringify(cssImports)},
      ...options
    }
    this.rootElement = null
    this.shadowRoot = null
    this.styleElement = null
    this.unmountFunction = null
  }

  async mount(container) {
    console.log('üîç mount called')
    if (this.rootElement) {
      this.unmount()
    }

    // Create root element
    this.rootElement = container || document.createElement('div')
    this.rootElement.id = this.options.rootElement
    if (this.options.rootClassName) {
      this.rootElement.className = this.options.rootClassName
    }

    // Create shadow root for style isolation
    this.shadowRoot = this.rootElement.attachShadow({ mode: 'open' })

    // Inject styles
    console.log('üîç About to call injectStyles')
    await this.injectStyles()

    // Render content
    const result = this.renderFunction(this.shadowRoot)
    if (typeof result === 'function') {
      this.unmountFunction = result
    }

    // Append to document if no container provided
    if (!container) {
      document.body.appendChild(this.rootElement)
    }
  }

  unmount() {
    if (this.unmountFunction) {
      this.unmountFunction()
      this.unmountFunction = null
    }

    if (this.rootElement && this.rootElement.parentNode) {
      this.rootElement.parentNode.removeChild(this.rootElement)
    }

    this.rootElement = null
    this.shadowRoot = null
    this.styleElement = null
  }

  async injectStyles() {
    console.log('üîç injectStyles called')
    const targetRoot = this.shadowRoot || this.rootElement

    // Create style element
    this.styleElement = document.createElement('style')
    targetRoot.appendChild(this.styleElement)

    // Fetch CSS using the working example pattern
    try {
      console.log('üîç About to call fetchCSS')
      const cssContent = await this.fetchCSS()
      console.log('üîç fetchCSS returned:', cssContent.substring(0, 100) + '...')
      this.styleElement.textContent = cssContent
      console.log('‚úÖ CSS injected successfully')
    } catch (error) {
      console.error('‚ùå Failed to inject CSS:', error)
    }

    // Setup HMR for CSS files
    this.setupCSSHMR()
  }

  async fetchCSS() {
    let allCSS = ''
    
    console.log('üîç Processing stylesheets:', this.options.stylesheets)
    
    for (const stylesheet of this.options.stylesheets) {
      try {
        console.log('üîç Processing stylesheet:', stylesheet)

        const cssUrl = new URL(stylesheet, import.meta.url)
        const response = await fetch(cssUrl)
        const text = await response.text()
        if (response.ok) {
          allCSS += text + '\\n'
        } else {
          console.warn('‚ö†Ô∏è Failed to fetch CSS:', stylesheet)
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Failed to fetch CSS:', stylesheet, error)
      }
    }
    
    return allCSS
  }

  setupCSSHMR() {
    if (!import.meta.webpackHot) return

    // Setup HMR for each CSS file
    for (const stylesheet of this.options.stylesheets) {
      import.meta.webpackHot?.accept(stylesheet, async () => {
        try {
          const cssContent = await this.fetchCSS()
          if (this.styleElement) {
            this.styleElement.textContent = cssContent
            console.log('‚úÖ CSS updated via HMR:', stylesheet)
          }
        } catch (error) {
          console.error('‚ùå Failed to update CSS via HMR:', stylesheet, error)
        }
      })
    }
  }
}

// Extract the render function from the original content script
function createRenderFunction(shadowRoot) {
  // Create container div
  const contentDiv = document.createElement('div')
  // No default class - let the content script handle its own styling

  // Create and append logo image
  const img = document.createElement('img')
  img.className = 'content_logo'
  // Use the logo from the original import
  img.src = logo || '../images/logo.png'
  contentDiv.appendChild(img)

  // Create and append title
  const title = document.createElement('h1')
  title.className = 'content_title'
  title.textContent = 'Welcome to your Content Script Extension'
  contentDiv.appendChild(title)

  // Create and append description paragraph
  const desc = document.createElement('p')
  desc.className = 'content_description'
  desc.innerHTML = 'Learn more about creating cross-browser extensions at '

  const link = document.createElement('a')
  link.href = 'https://extension.js.org'
  link.target = '_blank'
  link.textContent = 'https://extension.js.org'

  desc.appendChild(link)
  contentDiv.appendChild(desc)

  // Append the content div to shadow root
  shadowRoot.appendChild(contentDiv)

  return () => {
    contentDiv.remove()
  }
}

// Override the initial function to use the wrapper
async function initial() {
  console.log('üîç initial() function called')
  const wrapper = new ContentScriptWrapper(createRenderFunction, {})
  console.log('üîç ContentScriptWrapper created')
  await wrapper.mount()
  console.log('üîç wrapper.mount() called')
  return () => wrapper.unmount()
}



// Simple initialization like the original working code
let unmount

async function initialize() {
  if (unmount) {
    unmount()
  }
  
  // Use the wrapper instead of the original initial function
  const wrapper = new ContentScriptWrapper(createRenderFunction, {})
  wrapper.mount()
  unmount = () => wrapper.unmount()
}

if (import.meta.webpackHot) {
  import.meta.webpackHot?.accept()
  import.meta.webpackHot?.dispose(() => unmount?.())

  // Accept changes to this file
  import.meta.webpackHot?.accept(() => {
    initialize()
  })
}

if (document.readyState === 'complete') {
  initialize()
} else {
  document.addEventListener('readystatechange', () => {
    if (document.readyState === 'complete') {
      initialize()
    }
  })
}
`
  }

  // Generate TypeScript-compatible code for other frameworks
  const wrapperCode = `
// Content Script Wrapper - Auto-generated by Extension.js
// This wrapper provides Shadow DOM isolation and CSS injection for content scripts

// Original content script source
${source}

// Content script options interface
export interface ContentScriptOptions {
  rootElement?: string
  rootClassName?: string
  stylesheets?: string[]
}

// Content script instance interface
export interface ContentScriptInstance {
  mount: (container: HTMLElement) => void
  unmount: () => void
}

// Content script wrapper class
class ContentScriptWrapper {
  private rootElement: HTMLElement | null = null
  private shadowRoot: ShadowRoot | null = null
  private styleElement: HTMLStyleElement | null = null
  private renderFunction: (container: HTMLElement) => (() => void) | void
  private unmountFunction: (() => void) | null = null
  private options: ContentScriptOptions

  constructor(renderFunction: (container: HTMLElement) => (() => void) | void, options: ContentScriptOptions = {}) {
    this.renderFunction = renderFunction
    this.options = {
      rootElement: 'extension-root',
      rootClassName: undefined,
      stylesheets: ${JSON.stringify(cssImports)},
      ...options
    }
  }

  mount(container?: HTMLElement): void {
    if (this.rootElement) {
      this.unmount()
    }

    // Create root element
    this.rootElement = container || document.createElement('div')
    this.rootElement.id = this.options.rootElement!
    // Don't add containerClass since React component handles its own styling

    // Create shadow root for style isolation
    this.shadowRoot = this.rootElement.attachShadow({ mode: 'open' })

    // Inject styles
    this.injectStyles()

    // Render content
    const result = this.renderFunction(this.shadowRoot as any)
    if (typeof result === 'function') {
      this.unmountFunction = result
    }

    // Append to document if no container provided
    if (!container) {
      document.body.appendChild(this.rootElement)
    }
  }

  unmount(): void {
    if (this.unmountFunction) {
      this.unmountFunction()
      this.unmountFunction = null
    }

    if (this.rootElement && this.rootElement.parentNode) {
      this.rootElement.parentNode.removeChild(this.rootElement)
    }

    this.rootElement = null
    this.shadowRoot = null
    this.styleElement = null
  }

  /**
   * Inject styles using the working example pattern
   */
  private async injectStyles(): Promise<void> {
    const targetRoot = this.shadowRoot || this.rootElement!

    // Create style element
    this.styleElement = document.createElement('style')
    targetRoot.appendChild(this.styleElement)

    // Fetch CSS using the working example pattern
    try {
      const cssContent = await this.fetchCSS()
      this.styleElement.textContent = cssContent
      console.log('‚úÖ CSS injected successfully')
    } catch (error) {
      console.error('‚ùå Failed to inject CSS:', error)
    }

    // Setup HMR for CSS files
    this.setupCSSHMR()
  }

  /**
   * Fetch CSS using the working example pattern
   */
  private async fetchCSS(): Promise<string> {
    let allCSS = ''
    
    for (const stylesheet of this.options.stylesheets) {
      try {
        
        const cssUrl = new URL(stylesheet, import.meta.url)
        const response = await fetch(cssUrl)
        const text = await response.text()
        if (response.ok) {
          allCSS += text + '\\n'
        } else {
          console.warn('‚ö†Ô∏è Failed to fetch CSS:', stylesheet)
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Failed to fetch CSS:', stylesheet, error)
      }
    }
    
    return allCSS
  }

  /**
   * Setup CSS HMR using the working example pattern
   */
  private setupCSSHMR(): void {
    if (!import.meta.webpackHot) return

    // Setup HMR for each CSS file
    for (const stylesheet of this.options.stylesheets) {
      import.meta.webpackHot?.accept(stylesheet, async () => {
        try {
          const cssContent = await this.fetchCSS()
          if (this.styleElement) {
            this.styleElement.textContent = cssContent
            console.log('‚úÖ CSS updated via HMR:', stylesheet)
          }
        } catch (error) {
          console.error('‚ùå Failed to update CSS via HMR:', stylesheet, error)
        }
      })
    }
  }
}

/**
 * Initialize content script with wrapper
 */
function initializeContentScript(
  options: ContentScriptOptions,
  renderFunction: (container: HTMLElement) => (() => void) | void
): ContentScriptInstance {
  const wrapper = new ContentScriptWrapper(renderFunction, options)
  
  return {
    mount: (container?: HTMLElement) => wrapper.mount(container),
    unmount: () => wrapper.unmount()
  }
}

/**
 * Default export for the content script wrapper
 */
export default ContentScriptWrapper

/**
 * Auto-initialize the content script with the wrapper
 * This function automatically sets up the content script using the imported contentScript function
 */
export function autoInitializeContentScript(
  options: ContentScriptOptions = {}
): ContentScriptInstance {
  // Get the render function from the imported contentScript
  const renderFunction = contentScript(options)

  // Initialize with the wrapper using the detected CSS imports
  return initializeContentScript(options, renderFunction)
}

// Simple initialization like the original working code
let unmount: (() => void) | undefined

async function initialize() {
  if (unmount) {
    unmount()
  }
  
  // Get the render function from the contentScript function
  const renderFunction = contentScript({})
  const wrapper = new ContentScriptWrapper(renderFunction, {})
  wrapper.mount()
  unmount = () => wrapper.unmount()
}

if (import.meta.webpackHot) {
  import.meta.webpackHot?.accept()
  import.meta.webpackHot?.dispose(() => unmount?.())

  // Accept changes to this file
  import.meta.webpackHot?.accept(() => {
    initialize()
  })
}

if (document.readyState === 'complete') {
  initialize()
} else {
  document.addEventListener('readystatechange', () => {
    if (document.readyState === 'complete') {
      initialize()
    }
  })
}
`

  return wrapperCode
}

/**
 * Check if content script should use wrapper
 */
function shouldUseWrapper(
  source: string,
  manifest: any,
  projectPath: string,
  url: string
): boolean {
  // Check if the source has the 'use shadow-dom' directive
  const hasShadowDomDirective =
    source.includes("'use shadow-dom'") || source.includes('"use shadow-dom"')

  // Check if content scripts are configured
  if (!manifest.content_scripts) {
    return false
  }

  // Check if this file is referenced in any content script
  for (const contentScript of manifest.content_scripts) {
    if (!contentScript.js) continue

    for (const js of contentScript.js) {
      const absoluteUrl = path.resolve(projectPath, js as string)
      if (url.includes(absoluteUrl)) {
        // Apply wrapper by default for content scripts
        // The directive can be used to explicitly enable/disable
        return true
      }
    }
  }

  return false
}

export default function (this: LoaderContext, source: string) {
  const options = this.getOptions()
  const manifestPath = options.manifestPath
  const projectPath = path.dirname(manifestPath)
  const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf-8'))

  validate(schema, options, {
    name: 'scripts:add-content-script-wrapper',
    baseDataPath: 'options'
  })

  const url = urlToRequest(this.resourcePath)

  // Check if we should use the wrapper
  if (!shouldUseWrapper(source, manifest, projectPath, url)) {
    return source
  }

  // Detect framework and generate appropriate wrapper
  const framework = detectFramework(source, this.resourcePath)

  if (framework) {
    const wrapperCode = generateFrameworkWrapperCode(
      source,
      framework,
      this.resourcePath
    )
    return wrapperCode
  }

  return source
}
