// ██████╗ ███████╗██╗   ██╗███████╗██╗      ██████╗ ██████╗
// ██╔══██╗██╔════╝██║   ██║██╔════╝██║     ██╔═══██╗██╔══██╗
// ██║  ██║█████╗  ██║   ██║█████╗  ██║     ██║   ██║██████╔╝
// ██║  ██║██╔══╝  ╚██╗ ██╔╝██╔══╝  ██║     ██║   ██║██╔═══╝
// ██████╔╝███████╗ ╚████╔╝ ███████╗███████╗╚██████╔╝██║
// ╚═════╝ ╚══════╝  ╚═══╝  ╚══════╝╚══════╝ ╚═════╝ ╚═╝

import * as path from 'path'
import {Dirent} from 'fs'
import * as fs from 'fs/promises'
import * as messages from './messages'

export async function generateExtensionTypes(
  manifestDir: string,
  packageJsonDir: string
) {
  const extensionEnvFile = path.join(packageJsonDir, 'extension-env.d.ts')
  // TODO(cezaraugusto): consider this
  // const extensionPathsFile = path.join(packageJsonDir, 'extension-paths.d.ts')
  // Always use the published package path to ensure compatibility in monorepos
  const typePath = 'extension'

  const fileContent = `\
// Required Extension.js types for TypeScript projects.
// This file is auto-generated and should not be excluded.
// If you need additional types, consider creating a new *.d.ts file and
// referencing it in the "include" array of your tsconfig.json file.
// See https://www.typescriptlang.org/tsconfig#include for more information.
/// <reference types="${typePath}/types" />

// Polyfill types for browser.* APIs
/// <reference types="${typePath}/types/polyfill" />
`

  try {
    // Check if the file exists
    await fs.access(extensionEnvFile)

    // Read the file content
    const existingContent = await fs.readFile(extensionEnvFile, 'utf8')

    // Check if the file contains the "develop/dist/types" string
    if (existingContent.includes('develop/dist/types')) {
      // Rewrite previous path for versions < 2.0.0. See #162
      await fs.writeFile(extensionEnvFile, fileContent)
    }

    // Always rewrite the path to ensure it uses the correct published package path
    await fs.writeFile(extensionEnvFile, fileContent)
  } catch (err) {
    // File does not exist, continue to write it
    const manifest = require(path.join(manifestDir, 'manifest.json'))
    console.log(messages.writingTypeDefinitions(manifest))
    try {
      await fs.writeFile(extensionEnvFile, fileContent)
    } catch (writeErr) {
      console.log(messages.writingTypeDefinitionsError(writeErr))
    }
  }

  // TODO(cezaraugusto): consider this
  // Generate extension-paths.d.ts with unions for editor intellisense
  // try {
  //   const root = packageJsonDir
  //   async function listFiles(rel: string): Promise<string[]> {
  //     const dir = path.join(root, rel)
  //     const out: string[] = []
  //
  //     async function walk(d: string, base: string) {
  //       let entries: Dirent[] = []
  //       try {
  //         entries = await fs.readdir(d, {withFileTypes: true})
  //       } catch {
  //         return
  //       }
  //
  //       for (const e of entries) {
  //         if (e.name.startsWith('.')) continue
  //
  //         const abs = path.join(d, e.name)
  //         const r = path.posix.join(base, e.name)
  //
  //         if (e.isDirectory()) {
  //           await walk(abs, r)
  //         } else {
  //           out.push(r)
  //         }
  //       }
  //     }
  //
  //     await walk(dir, '')
  //
  //     return out.map((p) => p.replace(/\\\\/g, '/'))
  //   }
  //
  //   const [publicFiles, pageFiles, scriptFiles] = await Promise.all([
  //     listFiles('public').catch(() => []),
  //     listFiles('pages').catch(() => []),
  //     listFiles('scripts').catch(() => [])
  //   ])
  //
  //   function toLiterals(values: string[]): string {
  //     if (!values || values.length === 0) return 'never'
  //     return values.map((v) => `'${v.replace(/'/g, "\\'")}'`).join(' | ')
  //   }
  //
  //   // Public paths: expose three common forms for convenience
  //   const publicRel = publicFiles
  //   const publicWithPrefix = publicRel.map((p) => `public/${p}`)
  //   const publicWithSlashPrefix = publicRel.map((p) => `/public/${p}`)
  //   const publicRootSlash = publicRel.map((p) => `/${p}`)
  //
  //   const pages = pageFiles.map((p) => `pages/${p}`)
  //   const scripts = scriptFiles.map((p) => `scripts/${p}`)
  //
  //   const content = `
  // // Auto-generated by Extension.js. Literal unions for editor Intellisense.
  // // Do not edit manually.
  // declare namespace ExtensionPaths {
  //   type KnownPublic = ${toLiterals(publicWithPrefix)} | ${toLiterals(publicWithSlashPrefix)} | ${toLiterals(publicRootSlash)}
  //   type KnownPages = ${toLiterals(pages)}
  //   type KnownScripts = ${toLiterals(scripts)}
  //   type KnownPath = KnownPublic | KnownPages | KnownScripts
  // }
  //
  // // Helper overload for IDEs: getURL only accepts known paths
  // declare function __extensionjs_getURL<Path extends ExtensionPaths.KnownPath>(p: Path): string
  // export {}
  // `
  //
  //   await fs.writeFile(extensionPathsFile, content)
  // } catch (err) {
  //   // best effort; do not fail dev if generation fails
  // }
}
